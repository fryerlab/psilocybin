---
title: "Psilocybin Project 1"
subtitle: "Differential Expression"
author: "Kennedi Todd"
date: "10/14/2024"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

# Setup
## Working directory
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```

## Libraries
```{r libraries, message=FALSE, warning=FALSE}
library(dplyr)             # %>%
library(edgeR)             # to load .rds obj
library(ggrepel)           # geom_text_repel()
library(ggplot2)           # ggplot()
library(jsonlite)          # toJSON()
library(limma)             # to load .rds obj
library(pheatmap)          # pheatmap()
library(tidyr)             # pivot_wider()
library(WGCNA)             # pickSoftThreshold()
```

## User defined variables
```{r set_variables}
# Output directories and file paths
out <- "../results/all_samples_sex_specific_analysis/"
out2 <- "all_samples_sex_specific_analysis"
model <- "DEGs_with_hbb/"

# Colors and levels
treatment_order <- c("saline", "psilocybin")
treatment_colors <- c("gray60", "springgreen2")

sex_order <- c("M", "F")
sex_colors <- c("gold2", "purple")

group_order <- c("S.8h", "S.24h", "S.7d", 
                 "L.8h", "L.24h", "L.7d", 
                 "H.8h", "H.24h", "H.7d")
group_colors <- c("gray90", "gray60", "gray30", 
                  "lightblue", "cornflowerblue", "blue", 
                  "sienna1", "red2", "red4")

if (grepl("8_hours|24_hours|7_days", out2)) {
  print("time specific analysis")
  group_colors <- c("gray60","cornflowerblue","firebrick2")
}
```

## Save functions
```{r save_functions}
saveToPDF <- function(...) {
    d = dev.copy(pdf,...)
    dev.off(d)
}
```

## Load data
```{r read_DGEList}
dge.filtered.norm <- readRDS(paste0("../rObjects/",
                                    out2,
                                    "_DGEList_filtered_normalized.rds"))
dim(dge.filtered.norm)
head(colnames(dge.filtered.norm))
```

# Voom
## Design matrix
```{r design_matrix}
design <- ""

if (grepl("sex_specific", out2)) {
  print("sex specific analysis")
  group2 <- interaction(dge.filtered.norm$samples$group2)
  hbb <- dge.filtered.norm$samples$hbb_log2cpm
  design <- model.matrix(~ 0 + group2 + hbb)
  design.names <- gsub("group2","", colnames(design))
  colnames(design) <- design.names
} else if (grepl("both_sexes", out2)) {
  print("both sexes analysis")
  group <- interaction(dge.filtered.norm$samples$group)
  sex <- factor(dge.filtered.norm$samples$sex)
  hbb <- dge.filtered.norm$samples$hbb_log2cpm
  design <- model.matrix(~ 0 + group + sex + hbb)
  design.names <- gsub("group","", colnames(design))
  colnames(design) <- design.names
}

head(design)
```

## Contrasts
```{r contrasts}
myContrasts <- ""

if (out2 == "all_samples_sex_specific_analysis" | 
    out2 == "all_samples_sex_specific_combat_analysis") {
  myContrasts <- c("L.8h.F - S.8h.F", 
                   "L.8h.M - S.8h.M",
                   "L.24h.F - S.24h.F",
                   "L.24h.M - S.24h.M",
                   "L.7d.F - S.7d.F",
                   "L.7d.M - S.7d.M",
                   "H.8h.F - S.8h.F",
                   "H.8h.M - S.8h.M",
                   "H.24h.F - S.24h.F",
                   "H.24h.M - S.24h.M",
                   "H.7d.F - S.7d.F",
                   "H.7d.M - S.7d.M",
                   "S.8h.F - S.8h.M",
                   "S.24h.F - S.24h.M",
                   "S.7d.F - S.7d.M")
} else if (out2 == "all_samples_both_sexes_analysis" | 
           out2 == "all_samples_both_sexes_combat_analysis") {
  myContrasts <- c("L.8h - S.8h",
                   "L.24h - S.24h",
                   "L.7d - S.7d",
                   "H.8h - S.8h",
                   "H.24h - S.24h",
                   "H.7d - S.7d")
} else if (out2 == "24_hours_sex_specific_analysis") {
  myContrasts <- c("L.24h.F - S.24h.F",
                   "L.24h.M - S.24h.M",
                   "H.24h.F - H.24h.F",
                   "H.24h.M - H.24h.M",
                   "S.24h.F - S.24h.M",
                   "L.24h.F - S.24h.M",
                   "H.24h.F - H.24h.M")
} else if (out2 == "24_hours_both_sexes_analysis") {
  myContrasts <- c("L.24h - S.24h",
                   "H.24h - S.24h",
                   "H.24h - L.24h")
} else if (out2 == "8_hours_both_sexes_analysis") {
  myContrasts <- c("L.8h - S.8h",
                   "H.8h - S.8h",
                   "H.8h - L.8h")
} else if (out2 == "8_hours_sex_specific_analysis") {
  myContrasts <- c("L.8h.F - S.8h.F",
                   "L.8h.M - S.8h.M",
                   "H.8h.F - H.8h.F",
                   "H.8h.M - H.8h.M",
                   "S.8h.F - S.8h.M",
                   "L.8h.F - S.8h.M",
                   "H.8h.F - H.8h.M")
} else if (out2 == "7_days_both_sexes_analysis") {
  myContrasts <- c("L.7d - S.7d",
                   "H.7d - S.7d",
                   "H.7d - L.7d")
} else if (out2 == "7_days_sex_specific_analysis") {
  myContrasts <- c("L.7d.F - S.7d.F",
                   "L.7d.M - S.7d.M",
                   "H.7d.F - H.7d.F",
                   "H.7d.M - H.7d.M",
                   "S.7d.F - S.7d.M",
                   "L.7d.F - S.7d.M",
                   "H.7d.F - H.7d.M")
}

head(myContrasts)
```

## Quality weights
```{r voom}
# voom transform counts
v <- voomWithQualityWeights(dge.filtered.norm,
                            design,
                            plot = TRUE)

# condense gene info
genes <- v$genes
genes <- genes %>% select(all_of(c("gene_name_unique","gene_name",
                                   "gene_id","seqnames","start","end",
                                   "strand","exonic_length")))
v$genes <- genes

# save
path <- paste0(out, "postfiltering_QC/voom_gene_mean_var_weights")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)

# fits linear model for each gene given a series of arrays
fit <- lmFit(v, design)

# contrast design for differential expression
contrasts <- makeContrasts(
  contrasts = myContrasts,
  levels = design.names)
head(contrasts)

# save contrast names
allComparisons <- colnames(contrasts)
allComparisons # check

# run contrast analysis
vfit <- contrasts.fit(fit, contrasts = contrasts)

# Compute differential expression based on the empirical Bayes moderation of the
# standard errors towards a common value.
veBayesFit <- eBayes(vfit)
plotSA(veBayesFit, main = "Final Model: Mean-variance Trend")

# save
path <- paste0(out, "postfiltering_QC/voom_gene_final_mean_var")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)

# Cleanup
remove(fit,vfit,genes,design)
```

# Voom MDS Plots
## Sex
```{r mds_postfiltering_sex, warning=FALSE}
# loop through dimensions and top genes
names <- v$targets$sample_id
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         sex = v$targets$sex)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = sex, label = Sample)) + 
      geom_point(size = 3) +
      scale_color_manual(values = sex_colors) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out,"postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_sex")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}

remove(data)
```

## Group
```{r mds_postfiltering_group}
# loop through dimensions and top genes
names <- v$targets$group
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         group = v$targets$group)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = group, label = Sample)) + 
      geom_point(size = 3) +
      scale_color_manual(values = group_colors) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out, "postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_group")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}
```

## Time point
```{r mds_postfiltering_timepoint}
# loop through dimensions and top genes
names <- v$targets$sample_id
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         timepoint = v$targets$timepoint)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = timepoint, label = Sample)) + 
      geom_point(size = 3) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out, "postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_timepoint")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}
```

## Treatment
```{r mds_postfiltering_treatment}
# loop through dimensions and top genes
names <- v$targets$treatment
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         treatment = v$targets$treatment)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = treatment, label = Sample)) + 
      geom_point(size = 3) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out, "postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_treatment")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}
```

## RIN
```{r mds_postfiltering_RIN}
# loop through dimensions and top genes
names <- v$targets$sample_id
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         RIN = v$targets$RIN)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = RIN, label = Sample)) + 
      geom_point(size = 3) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      scale_color_gradientn(colors = c("red","yellow","lightblue","blue")) +
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out, "postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_RIN")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}
```


## Lane
```{r mds_postfiltering_ss}
# loop through dimensions and top genes
names <- v$targets$sample_id
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         lane = v$targets$lane)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = lane, label = Sample)) + 
      geom_point(size = 3) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out, "postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_lane")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}
```

## RNA Extraction
```{r mds_postfiltering_ss}
# loop through dimensions and top genes
names <- v$targets$sample_id
dims <- list(c(1,2),c(2,3),c(3,4))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    mds <- plotMDS(v, 
                   labels = names, 
                   top = numGenes,
                   plot = FALSE,
                   dim.plot = dim)

    toplot <- data.frame(DimX = mds$x, 
                         DimY = mds$y,
                         Sample = rownames(mds$distance.matrix.squared),
                         RNA_extraction_batch = v$targets$RNA_extraction_batch)
    
    x.lab <- paste0(mds$axislabel," ",mds$dim.plot[1]," (",
                    round(mds$var.explained[mds$dim.plot[1]] * 100, digits = 2),
                    "%)")
    y.lab <- paste0(mds$axislabel," ",mds$dim.plot[2]," (",
                    round(mds$var.explained[mds$dim.plot[2]] * 100, digits = 2),
                    "%)")
    
    p <- ggplot(toplot, aes(x = DimX, y = DimY, color = RNA_extraction_batch, label = Sample)) + 
      geom_point(size = 3) +
      theme_bw() +
      geom_text(aes(label = Sample), size=4, vjust = -1) +
      xlab(x.lab) + ylab(y.lab) + 
      ggtitle(paste0("MDS Filtered: Top ", numGenes, ", Log2(CPM)"))
    print(p)
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0(out, "postfiltering_QC/MDS_top_",
                   numGenes,"_genes/MDS_filtered_top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), 
                   "_colored_by_RNA_extraction")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}
```

# Differential Expressioin
## Number of DEGs
Identify number of differentially expressed genes.
```{r decide_tests}
# set thresholds
pval <- 0.01
my.lfc <- 0.2

# run tests
sumTable <- summary(decideTests(
  veBayesFit,
  adjust.method = "BH",
  p.value = pval,
  lfc = my.lfc
  ))
print(paste0(" FDRq < ", pval, ", LFC = ", my.lfc))
sumTable

# reformat table
sumTable <- as.data.frame(sumTable)
colnames(sumTable) <- c("direction", "comparison", "count")
sumTable <- sumTable |> 
  pivot_wider(names_from = comparison, values_from = count)
colnames(sumTable) <- gsub(" - ", "_vs_", colnames(sumTable))

# save table
path <- paste0(out, model, "DEG_tables/DEG_comparison_FDRq_", 
               format(pval, nsmall = 2), "_LFC_", format(my.lfc, nsmall = 2), 
               ".tsv")
write.table(sumTable, 
            path, 
            quote = FALSE, 
            sep = "\t")
```

## DEG heatmap
```{r}
# reformat before plotting
df <- as.data.frame(sumTable)
df <- df[!df$direction == "NotSig",]
rownames(df) <- df$direction
df$direction <- NULL
df <- t(df)

# set heatmap colors and names
meta <- data.frame(treatment = c(rep("low dose", 3),
                                rep("high dose", 3)),
                   timepoint = rep(c("8 hours", "24 hours", "7 days"), 2))
rownames(meta) <- rownames(df)
paletteLength <- 100
myColor <- colorRampPalette(c("white","#f0eb9e","darkgreen"))(paletteLength)
ann_colors = list(treatment = c(`low dose` = "cornflowerblue", 
                               `high dose` = "firebrick1"),
                  timepoint = c(`8 hours` = "gray",
                                `24 hours` = "gold",
                                `7 days` = "chartreuse2"))

# save
path <- paste0(out, model, "/DEG_tables/DEG_comparison_FDRq_",
               format(pval, nsmall = 2),
               "_LFC_", format(my.lfc, nsmall = 2),".pdf")
pdf(path, width = 8, height = 9)

# plot
pheatmap::pheatmap(df,
                   main = paste0("FDRq < ", pval, ", |LFC| > ", my.lfc),
                   treeheight_row = 0,
                   treeheight_col = 0,
                   color = myColor,
                   cluster_rows = FALSE,
                   annotation_row = meta,
                   annotation_colors = ann_colors,
                   display_numbers = round(df, digits = 0),
                   fontsize_number = 12,
                   number_color = "black")
```

## DEG heatmap sex specific
```{r}
# reformat before plotting
df <- as.data.frame(sumTable)
df <- df[!df$direction == "NotSig",]
rownames(df) <- df$direction
df$direction <- NULL
df <- t(df)

# set heatmap colors and names
meta <- data.frame(treatment = c(rep("low dose", 6),
                                rep("high dose", 6),
                                rep("saline", 3)),
                   sex = c(rep(c("female","male"),6), rep("both",3)),
                   timepoint = c(rep(c("8 hours","8 hours",
                                       "24 hours","24 hours",
                                       "7 days", "7 days"),
                                     2),
                                 "8 hours", 
                                 "24 hours", 
                                 "7 days"))
rownames(meta) <- rownames(df)
paletteLength <- 100
myColor <- colorRampPalette(c("white","#f0eb9e","darkgreen"))(paletteLength)
ann_colors = list(treatment = c(`low dose` = "cornflowerblue", 
                               `high dose` = "firebrick2",
                               `saline` = "gray"),
                  sex = c(female = 'chartreuse2',
                          male = 'chocolate4',
                          both = "pink"),
                  timepoint = c(`8 hours` = "gold",
                                `24 hours` = "purple",
                                `7 days` = "black"))

# save
path <- paste0(out, model, "/DEG_tables/DEG_comparison_FDRq_",
               format(pval, nsmall = 2),
               "_LFC_", format(my.lfc, nsmall = 2),".pdf")
pdf(path, width = 8, height = 9)

# plot
pheatmap::pheatmap(df,
                   main = paste0("FDRq < ", pval, ", |LFC| > ", my.lfc),
                   treeheight_row = 0,
                   treeheight_col = 0,
                   color = myColor,
                   cluster_rows = FALSE,
                   annotation_row = meta,
                   annotation_colors = ann_colors,
                   display_numbers = round(df, digits = 0),
                   fontsize_number = 12,
                   number_color = "black")
```

## DEG heatmap timepoint and sex specific
```{r}
# reformat before plotting
df <- as.data.frame(sumTable)
df <- df[!df$direction == "NotSig",]
rownames(df) <- df$direction
df$direction <- NULL
df <- t(df)

# set heatmap colors and names
meta <- data.frame(treatment = c(rep("low dose", 2),
                                rep("high dose", 2),
                                rep("other", 3)),
                   sex = c(rep(c("female","male"),2), rep("both",3)))
rownames(meta) <- rownames(df)
paletteLength <- 100
myColor <- colorRampPalette(c("white","#f0eb9e","darkgreen"))(paletteLength)
ann_colors = list(treatment = c(`low dose` = "cornflowerblue", 
                               `high dose` = "firebrick2",
                               `other` = "gray"),
                  sex = c(female = 'chartreuse2',
                          male = 'purple',
                          both = "gold"))

# save
path <- paste0(out, model, "/DEG_tables/DEG_comparison_FDRq_",
               format(pval, nsmall = 2),
               "_LFC_", format(my.lfc, nsmall = 2),".pdf")
pdf(path, width = 8, height = 9)

# plot
pheatmap::pheatmap(df,
                   main = paste0("FDRq < ", pval, ", |LFC| > ", my.lfc),
                   treeheight_row = 0,
                   treeheight_col = 0,
                   color = myColor,
                   cluster_rows = FALSE,
                   annotation_row = meta,
                   annotation_colors = ann_colors,
                   display_numbers = round(df, digits = 0),
                   fontsize_number = 12,
                   number_color = "black")
```

## DEG heatmap timepoint both sexes
```{r}
# reformat before plotting
df <- as.data.frame(sumTable)
df <- df[!df$direction == "NotSig",]
rownames(df) <- df$direction
df$direction <- NULL
df <- t(df)

# set heatmap colors and names
meta <- data.frame(category = c(rep("low dose", 1),
                                rep("high dose", 1),
                                rep("other", 1)))
rownames(meta) <- rownames(df)
paletteLength <- 100
myColor <- colorRampPalette(c("white","#f0eb9e","darkgreen"))(paletteLength)
ann_colors = list(category = c(`low dose` = "cornflowerblue", 
                               `high dose` = "firebrick2",
                               `other` = "gray"))

# save
path <- paste0(out, model, "/DEG_tables/DEG_comparison_FDRq_",
               format(pval, nsmall = 2),
               "_LFC_", format(my.lfc, nsmall = 2),".pdf")
pdf(path, width = 8, height = 9)

# plot
pheatmap::pheatmap(df,
                   main = paste0("FDRq < ", pval, ", |LFC| > ", my.lfc),
                   treeheight_row = 0,
                   treeheight_col = 0,
                   color = myColor,
                   cluster_rows = FALSE,
                   annotation_row = meta,
                   annotation_colors = ann_colors,
                   display_numbers = round(df, digits = 0),
                   fontsize_number = 12,
                   number_color = "black")
```

## Output DEG tables
```{r output_DEG_tables}
coef <- 1

for (i in allComparisons) {
  # title 
  title <- gsub(" ", "_", i)
  title <- gsub("-","vs", title)
  
  
  # p < 1, log2fc > 0 ----------------------------------------------------------
  vTopTableAll <-
    topTable(
      veBayesFit, 
      coef = coef,  
      n = Inf, 
      p.value = 1,
      lfc = 0,
      confint = TRUE
    )
  #output as txt file
  path <- paste(out, model, "DEG_tables/", title, "_FDRq_1.00_LFC_0.00.tsv", sep = "") 
  write.table(
    vTopTableAll,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  
  # p < 0.10, log2fc > 0.20 ----------------------------------------------------
  vTopTable1 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.10,
      lfc = 0.2,
      confint = TRUE
    )
  path <- paste(out, model, "DEG_tables/", title, "_FDRq_0.10_LFC_0.20.tsv", sep = "") 
  write.table(
    vTopTable1,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  
  # increment ------------------------------------------------------------------
  coef <- coef + 1
}
```

## Volcano
```{r volcano_plot, message=FALSE, eval=FALSE}
# set variables
thresh <- 0.1
my.lfc <- 0.2

# get file list
files <- list.files(paste0(out, model,"DEG_tables/"))
keep <- grep("_1.00_LFC_0.00.tsv", files)
files <- files[keep]
files <- paste0(out, model, "DEG_tables/", files)

for (i in files) {
  
  # read DEG file
  data <- read.delim(i,sep = "\t")
  
  # assign colors
  color_values <- vector()
  max <- nrow(data)
  for(row in 1:max){
    if (data$adj.P.Val[row] < thresh){
      if (data$logFC [row] > my.lfc){
        color_values <- c(color_values, 1) # 1 when logFC > my.lfc and FDRq < thresh
      } else if (data$logFC[row] < -my.lfc){
        color_values <- c(color_values, 2) # 2 when logFC < -my.lfc and FDRq < thresh
      } else {
        color_values <- c(color_values, 3) # 3 when logFC between -my.lfc and +my.lfc and FDRq < thresh
      }
    } else {
      color_values <- c(color_values, 3) # 3 when FDRq >= thresh
    }
  }
  data$color_adjpval <- factor(color_values)
  
 # comparison name
 comparison <- gsub(paste0(out, model, "DEG_tables/"), "", i)
 comparison <- gsub("_FDRq_1.00_LFC_0.00.tsv","",comparison)
    
 # plot only if there are DEGs with adj.P.Val < thresh
 num <- data[data$adj.P.Val < thresh,]
 num <- nrow(num)
 if(num != 0) {
   
    # subset genes to label
    up <- data[data$color_adjpval == 1,]
    up.sig <- up[order(up$adj.P.Val),][1:15,]
    up.lfc <- up[order(up$logFC, decreasing = TRUE),][1:15,]
    up30 <- rbind(up.sig,up.lfc)
    up30 <- up30[!duplicated(up30$gene_name_unique),]
    down <- data[data$color_adjpval == 2,]
    down.sig <- down[order(down$adj.P.Val),][1:15,]
    down.lfc <- down[order(down$logFC, decreasing = FALSE),][1:15,]
    down30 <- rbind(down.sig,down.lfc)
    down30 <- down30[!duplicated(down30$gene_name_unique),]
      
    # set manual colors
    if (!1 %in% unique(data$color_adjpval)) {
      my_colors <- c("blue","gray")
    } else if (!2 %in% unique(data$color_adjpval)) {
      my_colors <- c("red","gray")
    } else if (!1 %in% unique(data$color_adjpval) && !2 %in% unique(data$color_adjpval)) {
      my_colors <- c("gray")
    } else {
      my_colors <- c("red","blue","gray")
    }
      
    # set significance threshold
    hadjpval <- (-log10(max(data$P.Value[data$adj.P.Val < thresh], na.rm=TRUE)))

    # plot
    p <-
      ggplot(data = data, 
             aes(x = logFC,  # x-axis is logFC
                 y = -log10(P.Value),  # y-axis will be -log10 of P.Value
                 color = color_adjpval)) +  # color is based on factored color column
      geom_point(alpha = 0.8, size = 2) +  # create scatterplot, alpha makes points transparent
      theme_bw() +  # set color theme
      theme(legend.position = "none") +  # no legend
      scale_color_manual(values = my_colors) +  # set factor colors
      labs(
        title = "", # no main title
        x = expression(log[2](FC)), # x-axis title
         y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") # y-axis title
      ) +
      theme(axis.title.x = element_text(size = 15),
            axis.text.x = element_text(size = 15)) +
      theme(axis.title.y = element_text(size = 15),
            axis.text.y = element_text(size = 15)) +
      theme(plot.title = element_text(size = 15)) +
      geom_hline(yintercept = hadjpval,  #  horizontal line
                         colour = "#000000",
                         linetype = "dashed") +
      geom_vline(xintercept = -my.lfc,  #  vertical line
                         colour = "#000000",
                         linetype = "dashed") +
      geom_vline(xintercept = my.lfc,  #  vertical line
                         colour = "#000000",
                         linetype = "dashed") +
      ggtitle(paste0(comparison, ", adj.P.Val < ", thresh, ", LFC = ", my.lfc)) +
      geom_text_repel(data = up30,
                      aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                      size = 5,
                      color = "maroon", 
                      fontface="italic",
                      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                      ) +
      geom_text_repel(data = down30,
                      aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                      color = "navyblue", 
                      size = 5,
                      fontface="italic",
                      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                      ) +
      ylim(c(0,15))
     p
      
    # save
    path <- paste0(out, model, "volcano/", comparison, "_FDRq_", 
                   format(thresh, nsmall = 2), "_LFC_",
                   format(my.lfc, nsmall = 2), "_volcano.pdf")
    pdf(path, height = 8, width = 8)
    print(p)
    dev.off()
  }
} # end loop through variables
```


## Volcano - joe
```{r volcano_plot, message=FALSE, eval=FALSE}
# set variables
thresh <- 0.1
my.lfc <- 0.2

# get file list
files <- list.files(paste0(out, model,"DEG_tables/"))
keep <- grep("_1.00_LFC_0.00.tsv", files)
files <- files[keep]
files <- paste0(out, model, "DEG_tables/", files)

for (i in files) {
  
  # read DEG file
  data <- read.delim(i,sep = "\t")
  
  # assign colors
  color_values <- vector()
  max <- nrow(data)
  for(row in 1:max){
    if (data$adj.P.Val[row] < thresh){
      if (data$logFC [row] > my.lfc){
        color_values <- c(color_values, 1) # 1 when logFC > my.lfc and FDRq < thresh
      } else if (data$logFC[row] < -my.lfc){
        color_values <- c(color_values, 2) # 2 when logFC < -my.lfc and FDRq < thresh
      } else {
        color_values <- c(color_values, 3) # 3 when logFC between -my.lfc and +my.lfc and FDRq < thresh
      }
    } else {
      color_values <- c(color_values, 3) # 3 when FDRq >= thresh
    }
  }
  data$color_adjpval <- factor(color_values)
  
 # comparison name
 comparison <- gsub(paste0(out, model, "DEG_tables/"), "", i)
 comparison <- gsub("_FDRq_1.00_LFC_0.00.tsv","",comparison)
    
 # plot only if there are DEGs with adj.P.Val < thresh
 num <- data[data$adj.P.Val < thresh,]
 num <- nrow(num)
 if(num != 0) {
   
    # subset genes to label
    up <- data[data$color_adjpval == 1,]
    up.sig <- up[order(up$adj.P.Val),][1:15,]
    up.lfc <- up[order(up$logFC, decreasing = TRUE),][1:15,]
    up30 <- rbind(up.sig,up.lfc)
    up30 <- up30[!duplicated(up30$gene_name_unique),]
    down <- data[data$color_adjpval == 2,]
    down.sig <- down[order(down$adj.P.Val),][1:15,]
    down.lfc <- down[order(down$logFC, decreasing = FALSE),][1:15,]
    down30 <- rbind(down.sig,down.lfc)
    down30 <- down30[!duplicated(down30$gene_name_unique),]
      
    # set manual colors
    if (!1 %in% unique(data$color_adjpval)) {
      my_colors <- c("blue","gray")
    } else if (!2 %in% unique(data$color_adjpval)) {
      my_colors <- c("red","gray")
    } else if (!1 %in% unique(data$color_adjpval) && !2 %in% unique(data$color_adjpval)) {
      my_colors <- c("gray")
    } else {
      my_colors <- c("red","blue","gray")
    }
      
    # set significance threshold
    hadjpval <- (-log10(max(data$P.Value[data$adj.P.Val < thresh], na.rm=TRUE)))

    # plot
    p <-
      ggplot(data = data, 
             aes(x = logFC,  # x-axis is logFC
                 y = -log10(P.Value),  # y-axis will be -log10 of P.Value
                 color = color_adjpval)) +  # color is based on factored color column
      geom_point(alpha = 0.8, size = 2) +  # create scatterplot, alpha makes points transparent
      theme_bw() +  # set color theme
      theme(legend.position = "none") +  # no legend
      scale_color_manual(values = my_colors) +  # set factor colors
      labs(
        title = "", # no main title
        x = expression(log[2](FC)), # x-axis title
         y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") # y-axis title
      ) +
      theme(axis.title.x = element_text(size = 15),
            axis.text.x = element_text(size = 15)) +
      theme(axis.title.y = element_text(size = 15),
            axis.text.y = element_text(size = 15)) +
      theme(plot.title = element_text(size = 15)) +
      geom_hline(yintercept = hadjpval,  #  horizontal line
                         colour = "#000000",
                         linetype = "dashed") +
      geom_vline(xintercept = -my.lfc,  #  vertical line
                         colour = "#000000",
                         linetype = "dashed") +
      geom_vline(xintercept = my.lfc,  #  vertical line
                         colour = "#000000",
                         linetype = "dashed") +
      ggtitle(paste0(comparison, ", adj.P.Val < ", thresh, ", LFC = ", my.lfc)) +
      geom_text_repel(data = up30,
                      aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                      size = 5,
                      color = "maroon", 
                      fontface="italic",
                      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                      ) +
      geom_text_repel(data = down30,
                      aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                      color = "navyblue", 
                      size = 5,
                      fontface="italic",
                      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                      ) +
      ylim(c(0,9))
     p
      
    # save
    path <- paste0(out, model, "volcano/", comparison, "_FDRq_", 
                   format(thresh, nsmall = 2), "_LFC_",
                   format(my.lfc, nsmall = 2), "_volcano.pdf")
    pdf(path, height = 8, width = 8)
    print(p)
    dev.off()
  }
} # end loop through variables
```

## Single volcano
```{r}
# set variables
thresh <- 0.01
my.lfc <- 0.2

# get file list
files <- list.files(paste0(out, model,"DEG_tables/"))
keep <- grep("_1.00_LFC_0.00.tsv", files)
files <- files[keep]
files <- paste0(out, model, "DEG_tables/", files)
files <- files[grepl(pattern = "DEG_tables/S\\.", x = files)]

for (i in files) {
  
  # read DEG file
  data <- read.delim(i,sep = "\t")
  
  # filter out specific known sex-linked genes
  sex_linked <- c("Eif2s3y","Uty","Kdm5d","Ddx3y","Eif2s3x","Ddx3x","Kdm6a",
                  "Kdm5c","Med12")
  data <- data[!data$gene_name %in% sex_linked,]
  
  # assign colors
  color_values <- vector()
  max <- nrow(data)
  for(row in 1:max){
    if (data$adj.P.Val[row] < thresh){
      if (data$logFC [row] > my.lfc){
        color_values <- c(color_values, 1) # 1 when logFC > my.lfc and FDRq < thresh
      } else if (data$logFC[row] < -my.lfc){
        color_values <- c(color_values, 2) # 2 when logFC < -my.lfc and FDRq < thresh
      } else {
        color_values <- c(color_values, 3) # 3 when logFC between -my.lfc and +my.lfc and FDRq < thresh
      }
    } else {
      color_values <- c(color_values, 3) # 3 when FDRq >= thresh
    }
  }
  data$color_adjpval <- factor(color_values)
  
 # comparison name
 comparison <- gsub(paste0(out, model, "DEG_tables/"), "", i)
 comparison <- gsub("_FDRq_1.00_LFC_0.00.tsv","",comparison)
    
 # plot only if there are DEGs with adj.P.Val < thresh
 num <- data[data$adj.P.Val < thresh,]
 num <- nrow(num)
 if(num != 0) {
   
    # subset genes to label
    up <- data[data$color_adjpval == 1,]
    up.sig <- up[order(up$adj.P.Val),][1:15,]
    up.lfc <- up[order(up$logFC, decreasing = TRUE),][1:15,]
    up30 <- rbind(up.sig,up.lfc)
    up30 <- up30[!duplicated(up30$gene_name_unique),]
    down <- data[data$color_adjpval == 2,]
    down.sig <- down[order(down$adj.P.Val),][1:15,]
    down.lfc <- down[order(down$logFC, decreasing = FALSE),][1:15,]
    down30 <- rbind(down.sig,down.lfc)
    down30 <- down30[!duplicated(down30$gene_name_unique),]
      
    # set manual colors
    if (!1 %in% unique(data$color_adjpval)) {
      my_colors <- c("blue","gray")
    } else if (!2 %in% unique(data$color_adjpval)) {
      my_colors <- c("red","gray")
    } else if (!1 %in% unique(data$color_adjpval) && !2 %in% unique(data$color_adjpval)) {
      my_colors <- c("gray")
    } else {
      my_colors <- c("red","blue","gray")
    }
      
    # set significance threshold
    hadjpval <- (-log10(max(data$P.Value[data$adj.P.Val < thresh], na.rm=TRUE)))

    # plot
    p <-
      ggplot(data = data, 
             aes(x = logFC,  # x-axis is logFC
                 y = -log10(P.Value),  # y-axis will be -log10 of P.Value
                 color = color_adjpval)) +  # color is based on factored color column
      geom_point(alpha = 0.8, size = 2) +  # create scatterplot, alpha makes points transparent
      theme_bw() +  # set color theme
      theme(legend.position = "none") +  # no legend
      scale_color_manual(values = my_colors) +  # set factor colors
      labs(
        title = "", # no main title
        x = expression(log[2](FC)), # x-axis title
         y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") # y-axis title
      ) +
      theme(axis.title.x = element_text(size = 15),
            axis.text.x = element_text(size = 15)) +
      theme(axis.title.y = element_text(size = 15),
            axis.text.y = element_text(size = 15)) +
      theme(plot.title = element_text(size = 15)) +
      geom_hline(yintercept = hadjpval,  #  horizontal line
                         colour = "#000000",
                         linetype = "dashed") +
      geom_vline(xintercept = -my.lfc,  #  vertical line
                         colour = "#000000",
                         linetype = "dashed") +
      geom_vline(xintercept = my.lfc,  #  vertical line
                         colour = "#000000",
                         linetype = "dashed") +
      ggtitle(paste0(comparison, ", adj.P.Val < ", thresh, ", LFC = ", my.lfc)) +
      geom_text_repel(data = up30,
                      aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                      size = 5,
                      color = "maroon", 
                      fontface="italic",
                      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                      ) +
      geom_text_repel(data = down30,
                      aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                      color = "navyblue", 
                      size = 5,
                      fontface="italic",
                      max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                      )
     p
      
    # save
    path <- paste0(out, model, "volcano/sex_linked_removed_", comparison, "_FDRq_", 
                   format(thresh, nsmall = 2), "_LFC_",
                   format(my.lfc, nsmall = 2), "_volcano.pdf")
    pdf(path, height = 8, width = 8)
    print(p)
    dev.off()
  }
} # end loop through variables
```

## Metascape input
```{r}
# set variables
thresh <- 0.1
my.lfc <- 0.2

# get file list
files <- list.files(paste0(out, model,"DEG_tables/"))
keep <- grep("_1.00_LFC_0.00.tsv", files)
files <- paste0(out, model, "DEG_tables/", files[keep])

# intitalize table for command line version of metascape
msbio.df <- data.frame()

# loop through DEG files
for (i in 1:length(files)) {
  # read table
  data <- read.table(files[i], header = TRUE, sep = "\t")
  
  # filter based on adjusted p-value
  data <- data[data$adj.P.Val < thresh,]
  
  # create up-regulated gene list
  up <- data[data$logFC > my.lfc,]
  up <- up$gene_name
  
  # create down-regulated gene list
  down <- data[data$logFC < -my.lfc,]
  down <- down$gene_name
  
 # get the comparison name
 comparison <- gsub(paste0(out, model, "DEG_tables/"), "", files[i])
 comparison <- gsub("_FDRq_1.00_LFC_0.00.tsv","",comparison)
 
 # make two filenames for up and downregulated genes
 # include the comparison, adjusted p-value threshold, and logFC threshold
 up.filename <- paste0(out, model, "metascape_input/", comparison,
                       "_upregulated_FDRq_", format(thresh, nsmall = 2), 
                       "_LFC_", format(my.lfc, nsmall = 2), ".txt")
 down.filename <- paste0(out, model, "metascape_input/", comparison,
                         "_downregulated_FDRq_", format(thresh, nsmall = 2), 
                         "_LFC_", format(my.lfc, nsmall = 2), ".txt")
 
 
  # save the up and down-reulated gene lists
  write.table(x = up,
              file = up.filename,
              quote = FALSE,
              row.names = FALSE,
              col.names = FALSE)
  write.table(x = down,
              file = down.filename,
              quote = FALSE,
              row.names = FALSE,
              col.names = FALSE)
    
  # job for MSBio
  # if there are more than 10 up-regulated genes, add paths in json format for msbio job
  if (length(up) > 10) {
      msbio <- jsonlite::toJSON(list(
        input = gsub(paste0(out, model, "metascape_input/"),
                     "/data/metascape_input/",
                     up.filename),
        output = paste0("/data/metascape_output/",
                        comparison,
                        "_upregulated_", 
                        format(thresh, nsmall = 2), 
                        "_LFC_", format(my.lfc, nsmall = 2)),
        single = TRUE))
      msbio <- gsub("\\[","",msbio)
      msbio <- gsub("\\]","",msbio)
      msbio.df <- rbind(msbio.df, msbio)
  }
  # if there are more than 10 down-regulated genes, add paths in json format for msbio job
  if (length(down) > 10) {
      msbio <- jsonlite::toJSON(list(
        input = gsub(paste0(out, model, "metascape_input/"),
                     "/data/metascape_input/",
                     down.filename),
        output = paste0("/data/metascape_output/",
                        comparison,
                        "_downregulated_", 
                        format(thresh, nsmall = 2),
                        "_LFC_", 
                        format(my.lfc, nsmall = 2)),
        single = TRUE))
      msbio <- gsub("\\[","",msbio)
      msbio <- gsub("\\]","",msbio)
      msbio.df <- rbind(msbio.df, msbio)
  }
}

# save msbio job
write.table(x = msbio.df,
            file = paste0(out, model, "metascape_input/msbio.job"),
            quote = FALSE,
            row.names = FALSE,
            col.names = FALSE)
```

## Subset counts
```{r}
# normalize by sequencing depth
cpm <- cpm(dge.filtered.norm)

# extract DEG list for H vs S and L vs S for all time points
files <- paste0(out, model, "DEG_tables/", c("L.8h.F_vs_S.8h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "L.24h.F_vs_S.24h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "L.7d.F_vs_S.7d.F_FDRq_0.10_LFC_0.20.tsv",
                                             "H.8h.F_vs_S.8h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "H.24h.F_vs_S.24h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "H.7d.F_vs_S.7d.F_FDRq_0.10_LFC_0.20.tsv",
                                             "L.8h.M_vs_S.8h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "L.24h.M_vs_S.24h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "L.7d.M_vs_S.7d.M_FDRq_0.10_LFC_0.20.tsv",
                                             "H.8h.M_vs_S.8h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "H.24h.M_vs_S.24h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "H.7d.M_vs_S.7d.M_FDRq_0.10_LFC_0.20.tsv"))
files <- paste0(out, model, "DEG_tables/", c("L.8h_vs_S.8h_FDRq_0.10_LFC_0.20.tsv",
                                             "L.24h_vs_S.24h_FDRq_0.10_LFC_0.20.tsv",
                                             "L.7d_vs_S.7d_FDRq_0.10_LFC_0.20.tsv",
                                             "H.8h_vs_S.8h_FDRq_0.10_LFC_0.20.tsv",
                                             "H.24h_vs_S.24h_FDRq_0.10_LFC_0.20.tsv",
                                             "H.7d_vs_S.7d_FDRq_0.10_LFC_0.20.tsv"))

# init variables
genes <- NULL

# loop through files
for (i in files) {
  df <- read.delim2(i)
  genes <- c(genes, df$gene_name)
}

# subset cpm
genes <- unique(genes)
cpm <- as.data.frame(cpm)
cpm <- cpm[genes,]

# save
path <- paste0(out, "counts/CPM_filtered_by_DEGs.tsv")
write.table(cpm, path, quote = FALSE, sep = "\t")
```

# WGCNA
### Extract data
- WGCNA = Weigh Gene Co-Expression Network Analysis
```{r WGCNA}
# User defined variables
degs <- TRUE
wgcna_out <- paste0(out, "WGCNA/")
network_type <- "unsigned"

# Extract the log2 CPM values from the voom object and meta
voom_data <- t(v$E)
metadata <- v$targets
remove(v, veBayesFit, contrasts, dge.filtered.norm)

# if subsetting by DEGs
if (degs == TRUE) {
  # extract DEG list for H vs S and L vs S for all time points
  if(out2 == "all_samples_both_sexes_analysis") {
    files <- paste0(out, model, "DEG_tables/", c("L.8h_vs_S.8h_FDRq_0.10_LFC_0.20.tsv",
                                                 "L.24h_vs_S.24h_FDRq_0.10_LFC_0.20.tsv",
                                                 "L.7d_vs_S.7d_FDRq_0.10_LFC_0.20.tsv",
                                                 "H.8h_vs_S.8h_FDRq_0.10_LFC_0.20.tsv",
                                                 "H.24h_vs_S.24h_FDRq_0.10_LFC_0.20.tsv",
                                                 "H.7d_vs_S.7d_FDRq_0.10_LFC_0.20.tsv"))
  } else if (out2 == "all_samples_sex_specific_analysis") {
    files <- paste0(out, model, "DEG_tables/", c("L.8h.F_vs_S.8h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "L.24h.F_vs_S.24h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "L.7d.F_vs_S.7d.F_FDRq_0.10_LFC_0.20.tsv",
                                             "H.8h.F_vs_S.8h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "H.24h.F_vs_S.24h.F_FDRq_0.10_LFC_0.20.tsv",
                                             "H.7d.F_vs_S.7d.F_FDRq_0.10_LFC_0.20.tsv",
                                             "L.8h.M_vs_S.8h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "L.24h.M_vs_S.24h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "L.7d.M_vs_S.7d.M_FDRq_0.10_LFC_0.20.tsv",
                                             "H.8h.M_vs_S.8h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "H.24h.M_vs_S.24h.M_FDRq_0.10_LFC_0.20.tsv",
                                             "H.7d.M_vs_S.7d.M_FDRq_0.10_LFC_0.20.tsv"))
  }
  
  # init variables
  genes <- NULL
  
  # Loop through files
  for (i in files) {
    # Read the first row to check if there's data beyond the header
    df_preview <- try(read.delim2(i, nrows = 1), silent = TRUE)
    
    # Check if the file has data rows (i.e., df_preview has at least one row)
    if (inherits(df_preview, "try-error") || nrow(df_preview) == 0) {
      # Print a message if the file is empty (optional)
      message(paste("Skipping empty file:", i))
    } else {
      # Read the full file since it has data
      df <- read.delim2(i)
      
      # Append gene names to the genes vector
      genes <- c(genes, df$gene_name)
    }
  }
  
  # subset cpm
  genes <- unique(genes)
  
  # Filter with DEG list
  voom_data <- voom_data[,genes]
}

dim(voom_data)
```

### Soft thresh
- WGCNA requires an appropriate soft-thresholding power for network construction. \
- This step helps determine the adjacency matrix. \
- Commonly, powers between 4 and 12 are tested to see which power best approximates a scale-free topology. \
- Choose a power where the Scale Free Topology Model Fit (R^2) is above 0.8, if possible. If many are above 0.8 choose the inflection point.
```{r soft_threshold}
sft <- pickSoftThreshold(voom_data, powerVector = 1:20)

# Prepare the data for ggplot2
sft_data <- data.frame(
  Power = sft$fitIndices[, 1],
  ScaleFreeR2 = -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2]
)

# Plot the results to visualize the scale-free topology
ggplot(sft_data, aes(x = Power, y = ScaleFreeR2)) +
  geom_point(color = "red", size = 3) +  # Points in red
  geom_text(aes(label = Power), vjust = -0.5, size = 3.5) +  # Add labels for powers
  labs(
    x = "Soft Threshold (power)",
    y = "Scale Free Topology Model Fit, signed R^2",
    title = "Scale Independence"
  ) +
  theme_minimal() +
  scale_y_continuous(breaks = seq(-1, 1, by = 0.1))

remove(sft)
```

## Construct network
- mergeCutHeight: A value of 0.25 means that modules with a correlation of 0.75 or higher (1 - 0.25) between their eigengenes (the summary expression profiles for each module) will be merged. \
- minModuleSize: A minimum module size of 30 genes is a common recommendation in WGCNA to ensure that each module has enough genes for reliable downstream analysis \
```{r construct_network, eval=FALSE}
# from plot above
softPower <- 15

# run blockwiseModules
bwnet <- blockwiseModules(
  datExpr = voom_data,                 # Your gene expression data with genes as columns
  power = softPower,                   # Soft threshold power
  minModuleSize = 30,                  # Minimum module size
  mergeCutHeight = 0.25,               # Merging threshold for similar modules
  pamRespectsDendro = FALSE,           # Ignore PAM in dynamic cut
  reassignThreshold = 0,               # Reassign genes to modules with a min threshold
  numericLabels = TRUE,                # Use numeric module labels
  saveTOMs = TRUE,                      # Optionally save TOMs to disk
  networkType = network_type
)

# cleanup
remove(sft_data)
```

## Dendrogram
```{r WGCNA_dendrogram}
# save
pdf(file = paste0(wgcna_out, "cluster_dendrogram_filtered_by_degs.pdf"),
    height = 5,
    width = 10)

# Extract module labels and module colors
moduleLabels <- bwnet$colors
moduleColors <- labels2colors(moduleLabels)

# plot dendrogram with module colors
plotDendroAndColors(dendro = bwnet$dendrograms[[1]],
                    colors = moduleColors[bwnet$blockGenes[[1]]],
                    "Module Colors",
                    dendroLabels = FALSE,
                    hang = 0.03,
                    addGuide = TRUE,
                    guideHang = 0.05)
```

## ANOVA
```{r WGCNA_ANOVA}
# subset meta to columns of interest
meta <- metadata %>% select(c("group","group2","timepoint","treatment","dose",
                              "sex","hbb_log2cpm"))
meta[,1:6] <- as.data.frame(lapply(meta[,1:6], factor))

# Extract module eigengenes from the blockwiseModules output
module_eigengenes <- bwnet$MEs

# Get the unique module numbers from the column names of module eigengenes
unique_module_numbers <- as.numeric(sub("ME", "", colnames(module_eigengenes)))

# Create a unique mapping of module numbers to colors
# Here we use `match` to ensure that the module numbers align with the unique colors
module_color_map <- unique(moduleColors)[match(unique_module_numbers, unique(moduleLabels))]

# Assign these color names as the column names for module eigengenes
colnames(module_eigengenes) <- module_color_map

# make sure meta is ordered to match module_eigengenes
all.equal(rownames(meta), rownames(module_eigengenes))

# Initialize a data frame to store ANOVA p-values for each module-trait combination
anova_pvalues <- data.frame(matrix(nrow = ncol(module_eigengenes), ncol = ncol(meta)))
rownames(anova_pvalues) <- colnames(module_eigengenes)
colnames(anova_pvalues) <- colnames(meta)

# Loop through each module eigengene and each categorical variable in meta
for (module in colnames(module_eigengenes)) {
  for (trait in colnames(meta)) {
    if (is.factor(meta[[trait]])) {
      # Perform ANOVA for multi-level categorical variables
      anova_result <- summary(aov(module_eigengenes[[module]] ~ meta[[trait]]))
      anova_pvalues[module, trait] <- anova_result[[1]][["Pr(>F)"]][1]
    } else {
      # For numeric variables, calculate correlation and store p-value
      cor_result <- cor.test(module_eigengenes[[module]], 
                             meta[[trait]], 
                             use = "pairwise.complete.obs")
      anova_pvalues[module, trait] <- cor_result$p.value
    }
  }
}
remove(anova_result,cor_result)

# Convert the data frame to a numeric matrix
anova_pvalues <- as.matrix(anova_pvalues)

# Apply p.adjust to the entire matrix of p-values after flattening to a vector
adjustedAnovaPvalues <- matrix(
  p.adjust(as.vector(anova_pvalues), method = "BH"),
  nrow = nrow(anova_pvalues),
  ncol = ncol(anova_pvalues),
  dimnames = dimnames(anova_pvalues)
)

# save
pdf(file = paste0(wgcna_out, "module_trait_relationship_qval_filtered_by_degs.pdf"),
    height = 4,
    width = 4)

# Define color breaks for the heatmap
breaks <- seq(0, 1, length.out = 51)
colors <- colorRampPalette(c("darkgreen","gold","#fcf673","lightyellow","white"))(50)

# Plot heatmap of module-trait correlations
pheatmap(adjustedAnovaPvalues,
         main = "q-values",
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         color = colors,
         breaks = breaks,
         number_color = "black",
         display_numbers = round(adjustedAnovaPvalues, 4),
         fontsize_number = 6
)

# cleanup
remove(adjustedAnovaPvalues, anova_pvalues)
```

## Correlation
```{r WGCNA_correlation}
# Initialize a matrix to store correlation coefficients for each module-trait combination
moduleTraitCor <- matrix(nrow = ncol(module_eigengenes), ncol = ncol(meta))
rownames(moduleTraitCor) <- colnames(module_eigengenes)
colnames(moduleTraitCor) <- colnames(meta)

# Loop through each module eigengene and each trait in meta to calculate correlations
for (module in colnames(module_eigengenes)) {
  for (trait in colnames(meta)) {
    if (is.numeric(meta[[trait]])) {
      # For numeric traits, calculate Pearson correlation
      moduleTraitCor[module, trait] <- cor(module_eigengenes[[module]], meta[[trait]], use = "pairwise.complete.obs")
    } else {
      # For categorical traits, calculate correlation by encoding as numeric
      trait_numeric <- as.numeric(as.factor(meta[[trait]]))
      moduleTraitCor[module, trait] <- cor(module_eigengenes[[module]], trait_numeric, use = "pairwise.complete.obs")
    }
  }
}

# Save the correlation plot as PDF
pdf(file = paste0(wgcna_out,
                  "module_trait_relationship_correlation_filtered_by_degs.pdf"), 
    height = 4, width = 4)

# Define color breaks for the correlation heatmap
breaks <- seq(-1, 1, length.out = 51)
colors <- colorRampPalette(c("blue", "white", "red"))(50)

# Plot heatmap of module-trait correlations
pheatmap(moduleTraitCor,
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         color = colors,
         breaks = breaks,
         display_numbers = TRUE,
         number_color = "black",
         fontsize_number = 6,
         main = "correlation"
)

# cleanup
remove(moduleTraitCor)
```

## Export results
```{r WGCNA_export}
# check sample order is the same
all.equal(rownames(voom_data), rownames(module_eigengenes))

# create module df
module_df <- data.frame(
  module_color = moduleColors,
  gene_name = names(bwnet$colors)
)
module_df <- module_df %>%
  group_by(module_color) %>%
  summarise(genes = paste(gene_name, collapse = ",")) %>%
  ungroup()

# remove grey
module_df <- module_df[!module_df$module_color == "grey",]

# save
write.table(
  x = module_df,
  file = paste0(wgcna_out, "module_gene_table_filtered_by_degs.tsv"),
  sep = "\t",
  quote = FALSE,
  row.names = FALSE
)

# cleanup
remove(module_df)
```

## Hub genes
```{r}
# Identify the top hub gene in each module
top_hubs <- chooseTopHubInEachModule(
  datExpr = voom_data, 
  colorh = moduleColors,
  power = softPower,
  type = "unsigned"
)

# reformat
top_hubs <- as.data.frame(top_hubs)
top_hubs$module <- rownames(top_hubs)

# save
write.table(
  x = top_hubs,
  file = paste0(wgcna_out, "top_hubs_in_module_filtered_by_degs.tsv"),
  sep = "\t",
  quote = FALSE,
  row.names = FALSE
)
```

## Gene network test
```{r gene_network}
# user params
library(igraph)
module_colors <- unique(moduleColors)
module_colors <- module_colors[!module_colors %in% "grey"]
threshold <- 0.2

# create adjacency matrix
adjacency_matrix <- adjacency(datExpr = voom_data, 
                              power = softPower, 
                              type = "unsigned")

# looop through colors
for (module_color in module_colors) {
 # get genes for a specific module
  module_genes <- colnames(voom_data)[moduleColors == module_color]
  
  # Subset adjacency matrix to include only module genes
  module_adjacency <- adjacency_matrix[module_genes, module_genes]
  
  # Apply the threshold: values below the threshold are set to 0
  module_adjacency[module_adjacency < threshold] <- 0
  
  # Convert to an igraph object
  network <- graph_from_adjacency_matrix(
    adjmatrix = module_adjacency, 
    mode = "undirected", 
    weighted = TRUE, 
    diag = FALSE)
  
  # Remove Unconnected Nodes
  network <- delete_vertices(network, V(network)[degree(network) == 0])
  
  # Calculate degree (or centrality) to identify hubs
  hub_genes <- names(sort(degree(network), decreasing = TRUE)[1:5])  # Top 5 hubs
  
  pdf(file = paste0(wgcna_out, "gene_network_", module_color, ".pdf"),
      width = 12,
      height = 12)
  
  # plot network
  p <- plot(network, 
       vertex.color = ifelse(V(network)$name %in% hub_genes, "red", "lightblue"),
       vertex.size = ifelse(V(network)$name %in% hub_genes, 10, 5),  # Larger size for hubs
       vertex.label.cex = 0.6,      # Adjust label size
       vertex.label.color = "black",
       edge.width = E(network)$weight * 2,  # Edge thickness based on weight
       main = paste(module_color, "network, correlation threshold = ", threshold)) 
  print(p)
  dev.off()
}
```

# Power analysis
## Check power
```{r}
# design
group <- interaction(dge.filtered.norm$samples$group)
sex <- factor(dge.filtered.norm$samples$sex)
hbb <- dge.filtered.norm$samples$hbb
design <- model.matrix(~ 0 + group + sex + hbb)
design.names <- gsub("group","", colnames(design))
design.names <- gsub("sex", "", design.names)
colnames(design) <- design.names
head(design)

# find dispersion
dge.filtered.norm <- estimateDisp(dge.filtered.norm, design)
myDisp <- dge.filtered.norm$common.dispersion
myDisp

# get dataframes
counts <- as.data.frame(dge.filtered.norm$counts)
meta <- dge.filtered.norm$samples[,c("sample_id","group")]

# find avg count per group
mean.group <- counts |>
  mutate(gene = row.names(counts)) |>
  pivot_longer(-gene, names_to = "sample_id") |>
  left_join(meta, by = "sample_id") |>
  summarize(mean = mean(value), .by = c(gene, group)) |>
  pivot_wider(names_from = group, values_from = mean)
mean.group <- as.data.frame(mean.group)
rownames(mean.group) <- mean.group$gene
mean.group$gene <- NULL
mean.group <- round(mean.group, digits = 4)

# check mean read count for control group of interest
summary(mean.group)

# set var
maxGenes <- dim(dge.filtered.norm)[1]

# check power
check.power(nGenes = maxGenes, # total num genes
            pi0 = 1-((1771+1938)/maxGenes), # proportion of nonsig genes
            m = 10, # sample size
            mu = 7334, # mean read counts in a control group
            disp = myDisp, # dispersion for all genes
            fc = 0.2,
            up = 1938/(1771+1938), # proportion of DE genes that are upreg
            fdr = 0.05)
```
$pow_bh_ave
[1] 1

$fdr_bh_ave
[1] 0.03608035

$pow_qvalue_ave
[1] 1

$fdr_qvalue_ave
[1] 0.04992364

## Sample size calculator
```{r}
ssizeRNA_single(nGenes = 13000,                # total genes
                pi0 = 0.9,                     # proportion nonsig genes
                m = 4,                         # pseudo sample size
                mu = 7000,                     # pseudo mean counts in control group
                disp = 0.1,                    # pseudo dispersion
                fc = .2,                       # fold change
                up = 0.5,                      # percent up-reg of DE genes
                fdr = 0.05,                    # adjusted p value
                power = 0.8)                   # prob you accept alternative hypothesis
```



```{r}
sessionInfo()
```
